<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>ilegra</title>
 <link href="http://engineering.ilegra.com/atom.xml" rel="self"/>
 <link href="http://engineering.ilegra.com/"/>
 <updated>2014-05-06T21:43:30-03:00</updated>
 <id>http://engineering.ilegra.com</id>
 <author>
   <name>ilegra</name>
   <email></email>
 </author>

 
 <entry>
   <title>Design Session</title>
   <link href="http://engineering.ilegra.com/extreme-programming/2014/05/07/design-session/"/>
   <updated>2014-05-07T00:00:00-03:00</updated>
   <id>http://engineering.ilegra.com/extreme-programming/2014/05/07/design-session</id>
   <content type="html">&lt;p&gt;Desing Session, também conhecida como &lt;a href=&quot;http://guide.agilealliance.org/guide/quickdesign.html&quot; title=&quot;Quick Design Session&quot;&gt;Quick Design Session&lt;/a&gt;, é uma das práticas do &lt;a href=&quot;http://www.extremeprogramming.org&quot; title=&quot;Extreme Programming&quot;&gt;Extreme Programming&lt;/a&gt; presente no dia a dia do desenvolvimento de software da ilegra.&lt;/p&gt;

&lt;p&gt;A Design Session é um processo colaborativo de aprendizado e problematização no qual o objetivo é evoluir, iniciar ou afirmar um &lt;a href=&quot;http://martinfowler.com/articles/designDead.html&quot; title=&quot;Software Design&quot;&gt;design de software&lt;/a&gt;. É importante ressaltar que, ao contrário da &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_Design_Up_Front&quot; title=&quot;Big Design Up Front&quot;&gt;fase de Design proposta pelo modelo Waterfall&lt;/a&gt;, a Desing Session não se propõe a entender e resolver todo o problema antes da sua implementação, e sim levantar, de forma rápida, as principais variáveis envolvidas e propor um esboço que funcione como norte para o desenvolvimento.&lt;/p&gt;

&lt;h2&gt;Motivação&lt;/h2&gt;

&lt;p&gt;Essa é uma prática que lida diretamente com os aspectos de manutenção e flexibilidade do software, melhorando a qualidade e, por consequência, a velocidade de entrega do software. Além disso, a Design Session trabalha sob uma visão diferente da codificação e é um ótimo momento para os desenvolvedores buscarem um melhor entendimento do que será desenvolvido e proporem possíveis soluções para o problema em questão.&lt;/p&gt;

&lt;p&gt;As Design Sessions, seguidas de revisões, também podem ser utilizadas como um meio de melhorar algumas habilidades dos desenvolvedores, tais como: capacidade analítica e de abstração, comunicação com PO e com o time, entendimento geral do sistema e &lt;a href=&quot;http://en.wikipedia.org/wiki/How_to_Solve_It&quot; title=&quot;How to Solve it!&quot;&gt;problematização&lt;/a&gt;. &lt;/p&gt;

&lt;h2&gt;Como aplicamos na ilegra&lt;/h2&gt;

&lt;p&gt;As Design Sessions são aplicadas por um desenvolvedor ou em equipe, de forma rápida, em no máximo 30 minutos, embora por vezes despendemos mais tempo. &lt;/p&gt;

&lt;p&gt;Quando é feita por um desenvolvedor, este centraliza a comunicação com o Product Owner (afim de elucidar requisitos) e submete o esboço de sua solução à uma revisão (Design Review). Além disso, esse desenvolvedor fica incumbido de fazer um briefing explicando sua solução para a equipe que irá trabalhar no problema proposto. &lt;/p&gt;

&lt;p&gt;Quando é realizada em equipe, a Design Session é mais dinâmica e colaborativa dispensando revisão e briefing, e nesse caso, os requisitos já devem estar mais claros ou o Product Owner estar junto à equipe.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&quot;/public/design-session.jpg&quot; alt=&quot;Design Session colaborativa&quot; title=&quot;Design Session Colaborativa&quot;&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;A prática de Design Session, geralmente é aplicada por User Story e trabalhada em duas &lt;a href=&quot;https://www.youtube.com/watch?v=f84n5oFoZBc#t=320&quot; title=&quot;Hammock Driven Development&quot;&gt;etapas cíclicas&lt;/a&gt;. Em uma dessas etapas olhamos para o contexto do problema: variáveis, requisitos, natureza da informação, componentes envolvidos, participantes e etc. A outra etapa envolve a parte mais técnica do design de software e o ponto fundamental é esboçar a solução que vai nortear o desenvolvimento, nesta etapa estão envolvidos: &lt;a href=&quot;http://sourcemaking.com/design_patterns&quot; title=&quot;Design Patterns&quot;&gt;design patterns&lt;/a&gt;, &lt;a href=&quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&quot; title=&quot;SOLID&quot;&gt;SOLID&lt;/a&gt;, trade-off, algoritmo, estrutura de dados, &lt;a href=&quot;http://www.infoq.com/presentations/Simple-Made-Easy&quot; title=&quot;Simple Made Easy&quot;&gt;composição de componentes&lt;/a&gt;, entre outros.&lt;/p&gt;

&lt;h2&gt;O que aprendemos&lt;/h2&gt;

&lt;p&gt;Com a nossa experiência aplicando essa prática aprendemos que o nível de abstração que deve-se chegar no esboço do problema está mais relacionado ao próprio problema do que a alguma regra ou técnica. O que deve ser buscado é que o time &amp;quot;pegue a ideia&amp;quot; da solução proposta e, para tanto, algumas caixas desenhadas em um caderno mostrando relações e responsabilidades de componentes, por vezes, é o suficiente.&lt;/p&gt;

&lt;p&gt;Embora seja comum vermos diagramas de classes e componentes como resultados das Design Sessions, o uso ou padronização de linguagens de modelagem e ferramentas não é obrigatório. O principal objetivo dessa prática não é documentar software, e sim, visualizar o problema e comunicar um esboço de solução ao time. Aqui na ilegra,  geralmente utilizamos cadernos, quadros e &lt;a href=&quot;https://cacoo.com&quot; title=&quot;Cacoo&quot;&gt;cacoo&lt;/a&gt; como ferramentas. Já a linguagem de modelagem gráfica surge sozinha a partir dos gostos e experiência dos times e, na maioria das vezes, ela é um misto de UML, &lt;a href=&quot;http://www.agilemodeling.com/artifacts/crcModel.htm&quot; title=&quot;Class Responsibility Collaborator&quot;&gt;CRC&lt;/a&gt; e muita criatividade.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Podcast - Big Data</title>
   <link href="http://engineering.ilegra.com/podcast/2014/04/01/podcast-bigdata/"/>
   <updated>2014-04-01T00:00:00-03:00</updated>
   <id>http://engineering.ilegra.com/podcast/2014/04/01/podcast-bigdata</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Este é o terceiro episódio do Podcast &lt;a href=&quot;https://soundcloud.com/confraria-dos-arquitetos&quot; target=&quot;_blank&quot;&gt;&quot;Confraria dos Arquitetos&quot;&lt;/a&gt; e o assunto agora é: Big Data.
&lt;/div&gt;

&lt;p&gt;Christophe Marchal, Matheus Boschetti, Jackson Oliveira e Rafael Souza discutem sobre os tópicos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Surgimento do conceito de BigData;&lt;/li&gt;
&lt;li&gt;Aplicações e usos;&lt;/li&gt;
&lt;li&gt;Arquitetura típica;&lt;/li&gt;
&lt;li&gt;Hadoop, Hive, Pig, Map Reduce.&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;450&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/142540308&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;visual=true&quot;&gt;&lt;/iframe&gt;
</content>
 </entry>
 
 <entry>
   <title>Programação funcional - Composição</title>
   <link href="http://engineering.ilegra.com/functional-programming/2014/03/30/programacao-funcional-composicao/"/>
   <updated>2014-03-30T00:00:00-03:00</updated>
   <id>http://engineering.ilegra.com/functional-programming/2014/03/30/programacao-funcional-composicao</id>
   <content type="html">&lt;p&gt;O paradigma de programação funcional e suas diversas ramificações tem se mostrado uma área de estudo relevante no que diz respeito a escalabilidade de software, produtividade e simplicidade. Porém, há uma série de discussões que tratam da aplicação do paradigma a problemas concretos de negócio. Até que ponto deve-se considerar aplicar as soluções funcionais para questões fora do domínio matemático? E de que forma isto se dá? Para responder, é necessário desmistificar certas questões.&lt;/p&gt;

&lt;h1&gt;Funções&lt;/h1&gt;

&lt;p&gt;No mundo da programação imperativa, os tipos primitivos são valores e as funções são componentes que realizam operações modificando o estado da aplicação. Já no paradigma funcional, as funções tem uma posição privilegiada, a ponto de serem consideradas &lt;b&gt;cidadãos de primeira classe&lt;/b&gt; (Higher order functions). &lt;/p&gt;

&lt;p&gt;Isto significa dizer que no paradigma funcional uma função tem &lt;b&gt;o mesmo peso ou importância que um tipo primitivo&lt;/b&gt; (funções são valores). Sendo assim, elas aparecerão de forma muito mais frequente no decorrer dos seus blocos de código (funções podem receber ou retornar outras funções, por exemplo).&lt;/p&gt;

&lt;h1&gt;Complexidade&lt;/h1&gt;

&lt;p&gt;Como podemos resolver problemas de negócio complexos com funções? Complexidade é o ponto central aqui.&lt;/p&gt;

&lt;p&gt;Gerenciar a &lt;b&gt;complexidade&lt;/b&gt; é um dos maiores problemas encontrados durante o desenvolvimento de software e  também um ponto crucial na implementação de aplicações sustentáveis. Para gerenciar, o paradigma funcional tem uma solução:  a composição. Por meio de composição é possível criar complexidade a partir da simplicidade de acordo com a necessidade.&lt;/p&gt;

&lt;blockquote&gt;
Princípio da composicionalidade: Propriedade das expressões &lt;b&gt;complexas&lt;/b&gt; cujo sentido é determinado pelos sentidos dos seus &lt;b&gt;constituintes&lt;/b&gt; e pelas regras usadas para os &lt;b&gt;combinar&lt;/b&gt; - Infopédia 
&lt;/blockquote&gt;

&lt;h1&gt;Composição de funções - Classificação&lt;/h1&gt;

&lt;p&gt;A partir da ideia de composição, tem-se uma série de nomenclaturas utilizadas para &lt;b&gt;classificar os tipos de relações&lt;/b&gt; possíveis entre as funções. Surge aí, a noção de Applicatives, Functors, Monoids, Monads (dentre outros), frequentemente citados em diversas fontes de pesquisa relacionadas as linguagens funcionais. &lt;/p&gt;

&lt;p&gt;O conhecimento dos termos em si, não é estritamente necessário para quem está iniciando com o paradigma funcional, porém, na medida em que se buscam soluções mais robustas, sem que para isto haja perda de simplicidade, faz-se necessário cada vez mais o conhecimento e a familiaridade com estes conceitos para que se possa tirar um melhor proveito da linguagem e paradigma com o qual se está desenvolvendo.&lt;/p&gt;

&lt;h1&gt;Links úteis&lt;/h1&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://en.wikipedia.org/wiki/Function_composition_(computer_science)&quot;&gt;http://en.wikipedia.org/wiki/Function&lt;em&gt;composition&lt;/em&gt;(computer_science)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt;http://www.slideshare.net/calewis/jax-func-4557288&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt;http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt;http://aeflash.com/2013-06/monads.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;&quot;&gt;http://www.codecommit.com/blog/ruby/monads-are-not-metaphors&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Coherence</title>
   <link href="http://engineering.ilegra.com/datagrid/2014/03/27/coherence/"/>
   <updated>2014-03-27T00:00:00-03:00</updated>
   <id>http://engineering.ilegra.com/datagrid/2014/03/27/coherence</id>
   <content type="html">&lt;p&gt;Em um dos nossos projetos aqui na &lt;strong&gt;&lt;a  href=&quot;http://www.ilegra.com&quot; target=&quot;_blank&quot;&gt;ilegra&lt;/a&gt;&lt;/strong&gt;, tivemos a experiência de implantação do &lt;strong&gt;&lt;a  href=&quot;http://www.oracle.com/technetwork/middleware/coherence/overview/index.html&quot; target=&quot;_blank&quot;&gt;Coherence&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;No projeto, tínhamos um processo que podia demorar de alguns minutos até várias horas para terminar. O resultado do processamento poderia variar de alguns kilobytes até 800Mb. Melhorar a performance desse processo não era uma opção. O resultado desse processo era agregado a um resultado de pesquisa. Era aceitável a pesquisa demorar, mas reordenar os resultados da pesquisa ou aplicar qualquer filtro teria de ser rápido. &lt;/p&gt;

&lt;p&gt;A solução escolhida foi usar um data grid para armazenar os resultados do processo em cache e conseguir acessar esse resultado em alguns milissegundos. Normalmente, utiliza-se um data grid quando é necessário mais memória, do que uma única máquina. Um data grid roda em cima de um cluster de máquinas e distribui os dados entre os servidores. A ideia é que qualquer nodo consiga saber onde achar qualquer informação no cluster. Costumamos usar aqui na ilegra, soluções open source, por tal motivo, inicialmente optamos pelo &lt;strong&gt;&lt;a href=&quot;http://www.terracotta.org/&quot; target=&quot;_blank&quot;&gt;Terracota&lt;/a&gt;&lt;/strong&gt;. Porém, tivemos algumas dificuldades em configurar para descartar as chaves menos usadas. Como o cliente tinha uma licença para usar Coherence, acabamos migrando para essa solução. &lt;/p&gt;

&lt;p&gt;Abaixo listamos algumas estratégias de cache que testamos e a nossa visão sobre elas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;* Replicate Cache&lt;/strong&gt; - Todos os nodos do cache possuirão os mesmos dados com um rápido acesso. 
&lt;br/&gt;&lt;em&gt;Ideal:&lt;/em&gt; Quando a necessidade é uma resposta rápida e existe memória suficiente para colocar em todos os nodos.
&lt;br/&gt;&lt;em&gt;Observação:&lt;/em&gt; Quando o seu cache contiver muitos dados e o acesso aos dados não é constante, torna-se custoso manter todos seus nodos com todos os dados replicados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;* Distributed Cache&lt;/strong&gt; - Todos seus nodos possuem uma área onde guardam logicamente qual dos nodos contém a informação requisitada.
&lt;br/&gt;&lt;em&gt;Ideal:&lt;/em&gt; Tipologia ideal quando você possui muitas informações, mas ao mesmo tempo é custoso demais, em relação a memória, replicar esses dados em todos os nodos.
&lt;br/&gt;&lt;em&gt;Observação:&lt;/em&gt; Quanto o maior número de nodos, menor o espaço em memória necessário. Isto acontece porque cada nodo além de saber logicamente onde encontrar a informação, possui uma área primária para guardar os dados e um espaço de backup usado para recuperar as informações, caso um nodo desconecte.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;* Near Cache&lt;/strong&gt; - Cada nodo além de possuir a informação de onde os dados estão, igual ao Distributed Cache, possui uma área local em memória configurável que guarda alguns dados previamente acessados.
&lt;br/&gt;&lt;em&gt;Ideal:&lt;/em&gt; É considerado o mais balanceado dos três citados, principalmente, em relação ao custo benefício. Além de possuir informações locais já acessadas e de rápida resposta, não guarda fisicamente todos os dados.
&lt;br/&gt;&lt;em&gt;Observação:&lt;/em&gt; Esse tipo de tipologia tem um ganho de performance, quando o número de nodos do cache são altos e possuem um espaço considerável para guardar no cache local algumas informações, evitando assim tráfego desnecessário de rede.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Podcast - Arquiteturas ESP e CEP</title>
   <link href="http://engineering.ilegra.com/podcast/2014/01/23/arquiteturas-esp-e-cep/"/>
   <updated>2014-01-23T00:00:00-02:00</updated>
   <id>http://engineering.ilegra.com/podcast/2014/01/23/arquiteturas-esp-e-cep</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Este é o segundo episódio do Podcast &lt;a href=&quot;https://soundcloud.com/confraria-dos-arquitetos&quot; target=&quot;_blank&quot;&gt;&quot;Confraria dos Arquitetos&quot;&lt;/a&gt; e o assunto agora é: Arquiteturas ESP (Event Stream Processing) e CEP (Complex Event Processing).
&lt;/div&gt;

&lt;p&gt;Christophe Marchal, Matheus Boschetti, Jackson Oliveira e Rafael Souza discutem sobre os tópicos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Quais são as origens dessas arquiteturas;&lt;/li&gt;
&lt;li&gt;Quais vantagens elas trazem;&lt;/li&gt;
&lt;li&gt;Suas aplicações;&lt;/li&gt;
&lt;li&gt;Componentes típicos das arquiteturas;&lt;/li&gt;
&lt;li&gt;Qual a relação entre as duas siglas.&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/128526141&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;visual=true&quot;&gt;&lt;/iframe&gt;
</content>
 </entry>
 
 <entry>
   <title>Podcast - Semantic Web</title>
   <link href="http://engineering.ilegra.com/podcast/2014/01/06/semantic-web-podcast/"/>
   <updated>2014-01-06T00:00:00-02:00</updated>
   <id>http://engineering.ilegra.com/podcast/2014/01/06/semantic-web-podcast</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Primeiro episódio do Podcast  &lt;a href=&quot;https://soundcloud.com/confraria-dos-arquitetos&quot; target=&quot;_blank&quot;&gt;&quot;Confraria dos Arquitetos&quot;&lt;/a&gt;. Semantic Web é o tema da vez!
&lt;/div&gt;

&lt;p&gt;Christophe Marchal, Matheus Boschetti, Jackson Oliveira e Rafael Souza falam sobre o que é Semantic Web e Mashup, discutindo quais vantagens eles trazem e em que contexto podem ser aplicados.&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/125455234&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;visual=true&quot;&gt;&lt;/iframe&gt;
</content>
 </entry>
 

</feed>
